// Copyright (C) 2017 EDF R&D

#include "params_file.h"
#include "utils/strings_utils.h"
#include <fstream>
#include <iomanip>
#include <ctime>

ParamsFile::ParamsFile( const INIReader& theConfig )
    : myConfig( &theConfig )
{
}

ParamsFile::~ParamsFile()
{
}

int ParamsFile::write( const char* theParamsFile )
{
  std::ofstream aFile( theParamsFile );

  if ( !aFile.is_open() )
  {
    std::cerr << "Failed to open file : \"" << theParamsFile << "\"\n"
        << strerror( SYSERROR() ) << std::endl;
    return -1;
  }

  aFile << "// This file is generated by the GPUSPH problem_builder" << std::endl;
  aFile << "// It contains auto-generated parameters definitions." << std::endl;
  std::time_t aTime = std::time( NULL );
  std::tm* aT = std::localtime( &aTime );
  aFile << GENERATION_TIME_STR << aT->tm_year + 1900 << "." << aT->tm_mon << "."
      << aT->tm_mday << " at " << aT->tm_hour << ":" << aT->tm_min << ":"
      << aT->tm_sec << std::endl;

  aFile << std::endl;

  IniSections aSections = myConfig->GetSections();
  IniSections_Iter aCur = aSections.begin();
  for ( ; aCur != aSections.end(); aCur++ )
  {
    // Ignore user_functions section.
    if ( aCur->first == "user_functions" )
      continue;

    aFile << "// [" << aCur->first << "]" << std::endl;
    IniSection_Iter aPar = aCur->second.begin();
    for ( ; aPar != aCur->second.end(); aPar++ )
    {
      aFile << "#define " << GPUSPH_PREFIX << aCur->first << "_" << aPar->first
          << GPUSPH_SUFFIX << " " << aPar->second << std::endl;
      aFile << "#define " << GPUSPH_PREFIX << aCur->first << "_" << aPar->first
          << GPUSPH_SUFFIX << "NAN " << ( aPar->second.size() == 0 )
          << std::endl;
      aFile << "#define " << GPUSPH_PREFIX << aCur->first << "_" << aPar->first
          << "_" << stringToMacro( aPar->second ) << std::endl;
    }
    aFile << std::endl;
  }

  IndexedSections aSequences = myConfig->GetIndexedSections();
  IndexedSections_Iter aSeq = aSequences.begin();
  for ( ; aSeq != aSequences.end(); aSeq++ )
  {
    aFile << "//// Sequence of [" << aSeq->first << "] sections" << std::endl;
    aFile << "#define " << GPUSPH_PREFIX << aSeq->first << "_SECTIONS"
        << std::endl;
    aFile << "// Number of sections in " << aSeq->first << " sequence"
        << std::endl;
    int aSeqLen = aSeq->second.size();
    aFile << "#define " << GPUSPH_PREFIX << "NB_" << aSeq->first
        << GPUSPH_SUFFIX << " " << aSeqLen << std::endl;
    aFile << std::endl;
    // Gather map( parameter name -> map( section index -> parameter value ) ).
    std::map< std::string, std::map< int, std::string > > aVals;

    IndexedSection_Iter aSection = aSeq->second.begin();
    // Print all sections of the sequence
    for ( ; aSection != aSeq->second.end(); aSection++ )
    {
      std::string aName( aSeq->first );
      aName += "_" + patch::to_string( aSection->first );
      aFile << "// [" << aName << "]" << std::endl;
      IniSection_Iter aPar = aSection->second.begin();
      for ( ; aPar != aSection->second.end(); aPar++ )
      {
        bool isNan = ( aPar->second.size() == 0 );
        aFile << "#define " << GPUSPH_PREFIX << aName << "_" << aPar->first
            << GPUSPH_SUFFIX << " " << aPar->second << std::endl;
        aFile << "#define " << GPUSPH_PREFIX << aName << "_" << aPar->first
            << GPUSPH_SUFFIX << "NAN " << isNan << std::endl;
        aVals[ aPar->first ][ aSection->first ] =
            ( isNan ? "NAN" : aPar->second );
      }
      aFile << std::endl;
    }
    // Print one line lists of parameters values
    aFile << "// Values of parameters of " << aSeq->first << " sequence"
        << std::endl;
    std::map< std::string, std::map< int, std::string > >::iterator aPVals =
        aVals.begin();
    for ( ; aPVals != aVals.end(); aPVals++ )
    {
      // String values list
      std::string aStrVals;
      // Integer values list
      std::string aIntVals;
      // Boolean values list
      std::string aBoolVals;
      aFile << "#define " << GPUSPH_PREFIX << aSeq->first << "_"
          << aPVals->first << "_VALS" << GPUSPH_SUFFIX << " ";
      for ( int i = 0; i < aSeqLen; i++ )
      {
        if ( i )
        {
          aFile << ", ";
          aStrVals += ", ";
          aIntVals += ", ";
          aBoolVals += ", ";
        }

        if ( aPVals->second.find( i ) == aPVals->second.end() )
        {
          aFile << "NAN";
          aStrVals += "NULL";
          aIntVals += "-1";
          aBoolVals += "false";
        }
        else
        {
          aFile << aPVals->second[ i ];
          aStrVals += "\"" + aPVals->second[ i ] + "\"";
          aIntVals += aPVals->second[ i ];
          aBoolVals += aPVals->second[ i ];
        }
      }
      aFile << std::endl;
      aFile << "#define " << GPUSPH_PREFIX << aSeq->first << "_"
          << aPVals->first << "_STRVALS" << GPUSPH_SUFFIX << " " << aStrVals
          << std::endl;
      aFile << "#define " << GPUSPH_PREFIX << aSeq->first << "_"
          << aPVals->first << "_INTVALS" << GPUSPH_SUFFIX << " " << aIntVals
          << std::endl;
      aFile << "#define " << GPUSPH_PREFIX << aSeq->first << "_"
          << aPVals->first << "_BOOLVALS" << GPUSPH_SUFFIX << " " << aBoolVals
          << std::endl;
    }
    aFile << std::endl;
  }

  aFile.close();

  return 0;
}
